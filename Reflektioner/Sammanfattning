3.3
Teammedlemmar
Albin Brahimi
Ardian Qeriqi
Wille Norman

Projektets Git-länk
https://github.com/addefrr/PA1489-3.git

Konfigurationshantering
Konfigurationshantering används för att hålla reda på ändringar i projekt och dess konfigurationer, vilket hjälper till att säkerställa att alla använder samma version och miljö. Det underlättar samarbete och förhindrar konflikter i koden.

Arbetsflöde med Git
git clone: För att klona ett repo till den lokala maskinen.
git add: För att lägga till ändringar.
git commit: För att spara ändringarna lokalt.
git push: SFör att skicka ändringar till GitHub.
git pull: HFör att hämta uppdateringar från GitHub.

Erfarenheter av konfigurationshantering
Vad gick bra? 
Vi lyckades bra med att använda Git för att spåra våra ändringar och samarbeta effektivt. Det gjorde det enklare att hantera versioner av vår kod och hålla reda på vad som ändrades.

Vad gick mindre bra?
Även om Git fungerade bra för versionshantering, hade vi vissa utmaningar med att hantera konfigurationer och beroenden mellan olika miljöer. Ibland blev det svårt att hålla konfigurationsfiler konsekventa mellan teammedlemmarnas lokala miljöer och den gemensamma utvecklingsmiljön, vilket ledde till inkonsekvenser i körning av projektet.

Hur löste ni svårigheterna?
Vi löste utmaningarna genom att vara noga med att dokumentera alla nödvändiga konfigurationsändringar i vårt versionshanteringssystem. Vi använde Git för att spåra förändringar i konfigurationsfiler och såg till att varje utvecklare uppdaterade sin miljö manuellt baserat på dessa ändringar. Genom att skapa tydliga commit-meddelanden och regelbundet kommunicera i teamet kunde vi undvika större misstag och säkerställa att alla arbetade med samma uppsättning inställningar.

Vad lyckades ni inte lösa?
Vi lyckades inte fullt ut automatisera alla delar av vår konfigurationshantering, vilket innebar att vissa manuella justeringar fortfarande behövde göras beroende på teammedlemmarnas lokala system. Detta ledde till viss ineffektivitet och risk för misstag vid uppdateringar.

4.3
1.
Teammedlemmar
Albin Brahimi
Ardian Qeriqi
Wille Norman

2.
Projektets Git-länk
https://github.com/addefrr/PA1489-3.git


3.
Projektet i stort:
Vi har implementerat ett system för att hantera burgarbeställningar genom två separata Flask-applikationer. Den ena applikationen låter användare skicka beställningar (BurgerOrderer), medan den andra visar inkomna beställningar i köket (KitchenView). Båda applikationerna delar samma SQLite-databas för att lagra och visa beställningsdata. Genom Docker Compose hanteras varje applikation i sin egen container och tjänsterna körs parallellt.

Varje container:

    BurgerOrderer-containern ansvarar för att hantera beställningsformuläret och skicka data till databasen. Den lyssnar på port 5000.
    KitchenView-containern visar beställningar i köket och låter personalen se dem i realtid. Den lyssnar på port 5001 och delar databas med BurgerOrderer via en volym.

Varje modul:

    Flask-appar: Två Flask-applikationer implementeras, en för beställning och en för köksvisning, med en delad modell för att hantera beställningsdata.
    SQLite-databas: En gemensam databas används av båda apparna via SQLite för att lagra och hämta beställningar.
    Docker Compose: Sköter orkestreringen av de två separata tjänsterna och ser till att båda apparna delar samma databasmapp via volymer, samtidigt som de körs på olika portar.

4.
Vad gick bra?
    Helheten gick som planerat, vi lyckades skapa containrar som kan prata med varandra via en databas, vilket vi är väldigt nöjda med.

Vad gick mindre bra?
    Mängder med oförklarliga buggar som vi bara löste genom att göra om hela projektet, då vi inte hittade en enklare lösning.

Hur löste ni svårigheterna? Hade ni kunnat göra annorlunda?
    Vi löste helt enkelt svårigheterna genom att börja om flera gånger. Det hade nog varit effektivare om vi hade en bättre plan, men eftersom vi lärde oss under tiden vi gjorde programmet så hade det nästan varit omöjligt att göra en bra plan i förväg.

Vad lyckades ni inte lösa? Varför inte?
    Ett automatiserat system för att starta allt. Anledningen är att vi inte listade ut hur man skulle göra det, många problem med docker som vi inte kunde få svar på.

5.
Vad gick bra?
    Vi lyckades använda containers och dockerizea allting.

Vad gick mindre bra?
    Jag tror den stora svårigheten var att det tog extremt lång tid att få in allt i containers.

Hur löste ni svårigheterna? Hade ni kunnat göra annorlunda?
    Vi lyckades lösa svårigheterna efter många youtube tutorials. Det vi hade kunnat göra annorlunda hade varit om vi försökte använda containers redan från början av projektet, då det hade underlättat resten av projektets gång.



4. 
Kort sammanfattning om hur ni har genomfört testerna:
Testerna utfördes genom en enhetstestsession för BurgerOrderer-applikationen. Fokus låg på funktionen test_send_data där vi använde Visual Studio Code för att sätta brytpunkter, köra stegvisa genomgångar och övervaka hur variabler ändrades. Genom att använda brytpunkter på specifika ställen i koden kunde vi följa flödet för beställningsprocessen och analysera resultaten av testordrar.

5. Utskrift från er senaste testsession:

    Antal tester: Vi har skrivit flera enhetstester, inklusive specifika för att hantera orderinmatning, felhantering och olika typer av orderflöden.
    Vad de testar: Testerna fokuserade på att säkerställa att orderdata skickas korrekt, att systemet hanterar ofullständiga orderförsök, och att variabler i applikationen uppdateras som förväntat.
    Resultat: I vår senaste session körde vi fem enhetstester, varav tre lyckades och två misslyckades. De misslyckade testerna uppstod främst på grund av problem med datavalidering i beställningsprocessen.

6. Era erfarenheter om att skriva automatiserade enhetstester:

    Vad gick bra? Vi kunde identifiera fel och problem snabbare med hjälp av enhetstester och brytpunkter, vilket gjorde att vi bättre förstod kodflödet.
    Vad gick mindre bra? Vi hade inget välorganiserat system för testning, och vissa tester gav inte de resultat vi förväntade oss, vilket skapade frustration.
    Hur löste ni svårigheterna? Genom att förbättra vår användning av debug-verktyg i Visual Studio Code, inklusive brytpunkter och stegvist körning, kunde vi hitta och rätta till många problem.
    Vad lyckades ni inte lösa? Vi kunde inte fullt ut förbättra alla testresultat, särskilt på grund av problem med datavalidering och bristen på ett enhetligt testsystem.


Individuella ingengörsdagböcker:

Ardian:
https://github.com/addefrr/PA1489-3/blob/main/Reflektioner/Ardian

Albin:
https://github.com/addefrr/PA1489-3/blob/main/Reflektioner/Albin

Wille:
https://github.com/addefrr/PA1489-3/blob/main/Reflektioner/Wille

